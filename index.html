<!DOCTYPE html>
<html lang="en">
<head>
<title data-i18n="title">Resistance Level Upgrade Calculator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    /* Define CSS variables for consistent sizing */
    :root {
        --level-input-width: 45px; /* Enough for "Level" text + padding (max 2 digits) */
        --held-input-width: 130px; /* Comfortably fits "99,999,999,999" plus padding (16 chars) */

        /* Light Mode Colors (Default) */
        --bg-color: #f4f4f4;
        --container-bg: #fff;
        --border-color: #ccc;
        --text-color: #333;
        --header-text-color: #333;
        --input-border: #ddd;
        --hr-color: #eee;
        --link-color: #007bff; /* Example for future links */
        --button-bg: #e0e0e0;
        --button-text: #333;
        --button-hover-bg: #d0d0d0;
    }

    /* Dark Mode Colors */
    [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --container-bg: #2b2b2b;
        --border-color: #444;
        --text-color: #e0e0e0;
        --header-text-color: #f0f0f0;
        --input-border: #555;
        --hr-color: #444;
        --link-color: #8ab4f8; /* Lighter link for dark mode */
        --button-bg: #444;
        --button-text: #e0e0e0;
        --button-hover-bg: #555;
    }

    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: var(--bg-color); /* Use variable */
        color: var(--text-color); /* Use variable */
        display: flex;
        flex-direction: column; /* Stack children (container, bottom-controls, version) vertically */
        justify-content: flex-start; /* Align content from the top */
        align-items: center; /* Center items horizontally */
        min-height: 90vh;
        transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
    }
    .container {
        max-width: 550px;
        width: 100%;
        margin: 20px 0; /* Adjusted margin to allow space for language selector above */
        padding: 20px;
        border: 1px solid var(--border-color); /* Use variable */
        border-radius: 8px;
        background-color: var(--container-bg); /* Use variable */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    h2 {
        text-align: center;
        margin-top: 0;
        margin-bottom: 20px;
        line-height: 1.2;
        color: var(--header-text-color); /* Use variable */
    }
    .row {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        flex-wrap: nowrap; /* Prevent wrapping on desktop by default */
    }
    /* Labels and display spans for general rows */
    .row .display-label,
    .row label {
        flex: 1; /* Labels take available space, can grow/shrink but prefer content size */
        margin-right: 15px; /* Controlled space between label and input */
        min-width: unset; /* Remove previous min-width that was causing large gaps */
        text-align: left; /* Align text to the left within its own space */
    }
    /* Inputs and select for general rows - NOW FIXED WIDTH on desktop */
    .row input[type="tel"],
    .row select {
        flex: 0 0 var(--held-input-width); /* Fixed width for consistency */
        padding: 8px;
        border: 1px solid var(--input-border); /* Use variable */
        border-radius: 44px;
        box-sizing: border-box;
        text-align: right; /* Keep numbers aligned to the right */
        max-width: var(--held-input-width); /* Ensure it doesn't grow if flex: 1 was somehow applied */
        background-color: var(--container-bg); /* Match container bg */
        color: var(--text-color); /* Match text color */
    }
    /* Specific override for timezoneSelect - allow it to be wider */
    #timezoneSelect {
        flex: 1; /* Allows timezone select to take available space */
        max-width: unset; /* Override max-width to allow it to be wider than other inputs */
        width: 100%; /* Fill available space as it is flex:1 */
    }
    /* Display values for general rows - NOW FIXED WIDTH on desktop */
    .display-value {
        font-weight: bold;
        color: var(--text-color); /* Use variable */
        flex: 0 0 var(--held-input-width); /* Fixed width for consistency */
        text-align: right; /* Ensure right justification */
        padding: 8px; /* Match input padding for alignment */
        min-width: unset; /* Remove previous min-width that was causing large gaps */
        box-sizing: border-box;
        max-width: var(--held-input-width); /* Apply same max-width for consistency */
    }


    /* Specific styling for building input rows to create columns */
    .building-row {
        display: grid;
        /* First column (labels) takes 'auto' space (content width), others use fixed widths */
        grid-template-columns: auto var(--level-input-width) var(--held-input-width);
        gap: 15px; /* Increased gap for better visual separation */
        align-items: center;
        margin-bottom: 8px;
    }
    .building-row label { /* Label for building names (e.g., Quartz Building 1) */
        grid-column: 1;
        text-align: left;
        margin-right: 0;
        min-width: unset;
    }
    /* Building input fields - now strictly adhere to defined widths */
    .building-row input[id^="level"] {
        grid-column: 2;
        width: 100%; /* Fill its grid cell */
        max-width: var(--level-input-width); /* Ensure it doesn't exceed its defined width */
        padding: 8px; /* Consistent padding */
        border: 1px solid var(--input-border); /* Use variable */
        border-radius: 4px;
        box-sizing: border-box;
        text-align: right;
        background-color: var(--container-bg);
        color: var(--text-color);
    }
    .building-row input[id^="resource"] {
        grid-column: 3;
        width: 100%; /* Fill its grid cell */
        max-width: var(--held-input-width); /* Ensure it doesn't exceed its defined width */
        padding: 8px; /* Consistent padding */
        border: 1px solid var(--input-border); /* Use variable */
        border-radius: 4px;
        box-sizing: border-box;
        text-align: right;
        background-color: var(--container-bg);
        color: var(--text-color);
    }

    .header-row {
        font-weight: bold;
        margin-bottom: 5px;
        display: grid;
        /* Match building-row columns exactly */
        grid-template-columns: auto var(--level-input-width) var(--held-input-width);
        gap: 15px; /* Match building-row gap */
    }
    .header-row span:first-child { /* The empty span for layout */
        text-align: left;
        grid-column: 1;
    }
    .header-row strong { /* Changed labels to strong for header semantic */
        grid-column: auto;
        text-align: center;
    }
    hr {
        border: 0;
        height: 1px;
        background: var(--hr-color); /* Use variable */
        margin: 15px 0;
    }

    /* --- Bottom Controls Styling --- */
    #bottom-controls {
        display: flex;
        justify-content: space-between; /* Pushes items to opposite ends */
        align-items: center;
        width: 100%;
        max-width: 550px; /* Match container width for alignment */
        margin-top: 20px; /* Space above version info */
        padding: 0 20px; /* Horizontal padding to match container if needed, or adjust */
        box-sizing: border-box; /* Ensure padding is included in width */
    }

    #language-selector-container {
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 5px 0;
    }
    #language-selector-container label {
        margin: 0;
        flex: none;
    }
    #languageSelect {
        padding: 5px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--container-bg);
        color: var(--text-color);
        cursor: pointer;
        min-width: 100px;
    }

    /* --- Theme Toggle Button Styling --- */
    #theme-toggle,
    #instructions-button { /* Apply similar styling to both buttons */
        padding: 8px 12px;
        background-color: var(--button-bg);
        color: var(--button-text);
        border: 1px solid var(--input-border);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    #theme-toggle:hover,
    #instructions-button:hover {
        background-color: var(--button-hover-bg);
    }
    #instructions-button {
        font-size: 1.2em; /* Make question mark larger */
        padding: 5px 10px; /* Adjust padding for icon */
        line-height: 1; /* Align text within button */
    }


    /* --- Version Info Styling --- */
    .version-info {
        margin-top: 15px; /* Small margin after bottom-controls */
        font-size: 0.8em;
        color: var(--text-color); /* Use variable */
        text-align: center;
    }

    /* --- Modal Styles --- */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
    }

    .modal-content {
        background-color: var(--container-bg);
        margin: auto; /* Auto margin for centering */
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        width: 90%; /* Responsive width */
        max-width: 500px; /* Max width for larger screens */
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        position: relative; /* For close button positioning */
        color: var(--text-color);
        line-height: 1.5;
        max-height: 80vh; /* Limit height to prevent modal from going off-screen */
        overflow-y: auto; /* Enable vertical scroll if content is too long */
    }

    .modal-close-button {
        color: var(--text-color);
        font-size: 28px;
        font-weight: bold;
        position: absolute;
        top: 10px;
        right: 15px;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
        line-height: 1;
    }

    .modal-close-button:hover,
    .modal-close-button:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }

    .modal-content h3 {
        color: var(--header-text-color);
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.5em;
        text-align: center;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }

    .modal-content p {
        margin-bottom: 10px;
    }

    .modal-content ul {
        list-style: disc;
        padding-left: 20px;
        margin-bottom: 10px;
    }
    .modal-content ul li strong {
        color: var(--header-text-color); /* Keep strong text within modal distinct */
    }

    /* --- Media Queries for Mobile Responsiveness (max-width: 480px) --- */
    @media (max-width: 480px) {
        body {
            font-size: 15px; /* Reduced base font size for better mobile fit */
        }

        /* Main Container */
        .container {
            max-width: 95%;
            margin: 10px auto;
            padding: 15px;
        }

        h2 {
            font-size: 1.3em; /* Slightly smaller for mobile */
            margin-bottom: 15px;
        }

        /* General rows on mobile (e.g., Resource Held) */
        .row {
            flex-wrap: nowrap; /* IMPORTANT: Prevent wrapping labels/inputs onto new line */
            justify-content: space-between; /* Space out label and input */
        }
        .row .display-label,
        .row label {
            flex: 0 1 auto; /* Allow label to shrink if needed (flex-shrink: 1), but prefer content size */
            min-width: 0; /* Allow content to shrink below its intrinsic width */
            margin-right: 10px; /* Keep a small gap */
            font-size: 1em; /* Adjust relative to new body font-size */
        }
        /* Inputs and display values for general rows on mobile */
        .row input[type="tel"],
        .display-value {
            flex: 1 1 auto; /* Allow input to fill remaining space, can shrink (flex-shrink: 1) */
            min-width: 0; /* Allow input to shrink below its intrinsic width */
            text-align: right !important; /* Force right justification on mobile */
            font-size: 1em; /* Adjust relative to new body font-size */
            max-width: 120px; /* Adjusted from 85px to better fit large numbers */
        }
        /* Specific overrides for timezoneSelect on mobile */
        #timezoneSelect {
            flex: 1; /* Takes available space */
            max-width: 100%; /* Ensure it doesn't overflow */
            width: 100%;
        }


        /* Building rows on mobile */
        .building-row {
            display: grid; /* Keep grid */
            /* Precise mobile column widths for strict alignment and consistent sizing */
            grid-template-columns: minmax(80px, 1fr) 40px 120px; /* Adjusted last column from 85px to 120px */
            gap: 8px; /* Slightly reduced gap on mobile */
            align-items: center; /* Ensure vertical alignment */
        }
        /* Make inputs fill their grid columns on mobile and remove desktop max-width */
        .building-row input[id^="level"] {
            width: 100%;
            max-width: unset; /* Remove desktop fixed width constraints */
            font-size: 0.9em;
            padding: 5px; /* Smaller padding for mobile */
            text-align: right !important; /* Force right justification on mobile */
        }
        .building-row input[id^="resource"] {
            width: 100%;
            max-width: unset; /* Remove desktop fixed width constraints */
            font-size: 0.9em;
            padding: 5px; /* Smaller padding for mobile */
            text-align: right !important; /* Force right justification on mobile */
        }
        .building-row label {
            font-size: 0.9em;
            padding: 0; /* Remove padding if not needed */
        }

        .header-row {
            /* Match building-row on mobile for perfect alignment */
            grid-template-columns: minmax(80px, 1fr) 40px 120px; /* Adjusted last column from 85px to 120px */
            gap: 8px;
            font-size: 0.9em; /* Match building row labels */
        }

        /* Bottom controls on mobile - REVISED for alignment */
        #bottom-controls {
            flex-direction: row; /* Keep them in a row */
            justify-content: space-between; /* Push to left and right */
            align-items: center;
            gap: 10px; /* Space between them */
            margin-top: 15px;
            padding: 0 15px; /* Adjust padding to match container's inner padding */
            max-width: 95%; /* Limit overall width */
            box-sizing: border-box; /* Ensure padding is included in width */
            flex-wrap: nowrap; /* Prevent wrapping on mobile */
        }
        #language-selector-container {
            justify-content: flex-end; /* Push language selector to the right */
            width: auto; /* Allow content to dictate width */
            flex-shrink: 0; /* Prevent shrinking */
            /* Ensure alignment with theme toggle */
            display: flex; /* Explicitly set flex to ensure alignment */
            align-items: center; /* Vertically align with button */
        }
        #theme-toggle {
            align-self: center; /* Ensure vertical alignment to center */
            width: fit-content;
            padding: 6px 10px;
            font-size: 0.85em;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #instructions-button { /* Adjust for mobile if needed */
            font-size: 1.1em; /* Slightly smaller on mobile if desired */
            padding: 4px 8px; /* Adjusted padding */
        }


        .version-info {
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--text-color);
            text-align: center;
        }

    /* --- Modal Styles --- */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
    }

    .modal-content {
        background-color: var(--container-bg);
        margin: auto; /* Auto margin for centering */
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        width: 90%; /* Responsive width */
        max-width: 500px; /* Max width for larger screens */
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        position: relative; /* For close button positioning */
        color: var(--text-color);
        line-height: 1.5;
        max-height: 80vh; /* Limit height to prevent modal from going off-screen */
        overflow-y: auto; /* Enable vertical scroll if content is too long */
    }

    .modal-close-button {
        color: var(--text-color);
        font-size: 28px;
        font-weight: bold;
        position: absolute;
        top: 10px;
        right: 15px;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
        line-height: 1;
    }

    .modal-close-button:hover,
    .modal-close-button:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }

    .modal-content h3 {
        color: var(--header-text-color);
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.5em;
        text-align: center;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }

    .modal-content p {
        margin-bottom: 10px;
    }

    .modal-content ul {
        list-style: disc;
        padding-left: 20px;
        margin-bottom: 10px;
    }
    .modal-content ul li strong {
        color: var(--header-text-color); /* Keep strong text within modal distinct */
    }

    /* --- Media Queries for Mobile Responsiveness (max-width: 480px) --- */
    @media (max-width: 480px) {
        body {
            font-size: 15px; /* Reduced base font size for better mobile fit */
        }

        /* Main Container */
        .container {
            max-width: 95%;
            margin: 10px auto;
            padding: 15px;
        }

        h2 {
            font-size: 1.3em; /* Slightly smaller for mobile */
            margin-bottom: 15px;
        }

        /* General rows on mobile (e.g., Resource Held) */
        .row {
            flex-wrap: nowrap; /* IMPORTANT: Prevent wrapping labels/inputs onto new line */
            justify-content: space-between; /* Space out label and input */
        }
        .row .display-label,
        .row label {
            flex: 0 1 auto; /* Allow label to shrink if needed (flex-shrink: 1), but prefer content size */
            min-width: 0; /* Allow content to shrink below its intrinsic width */
            margin-right: 10px; /* Keep a small gap */
            font-size: 1em; /* Adjust relative to new body font-size */
        }
        /* Inputs and display values for general rows on mobile */
        .row input[type="tel"],
        .display-value {
            flex: 1 1 auto; /* Allow input to fill remaining space, can shrink (flex-shrink: 1) */
            min-width: 0; /* Allow input to shrink below its intrinsic width */
            text-align: right !important; /* Force right justification on mobile */
            font-size: 1em; /* Adjust relative to new body font-size */
            max-width: 120px; /* Adjusted from 85px to better fit large numbers */
        }
        /* Specific overrides for timezoneSelect on mobile */
        #timezoneSelect {
            flex: 1; /* Takes available space */
            max-width: 100%; /* Ensure it doesn't overflow */
            width: 100%;
        }


        /* Building rows on mobile */
        .building-row {
            display: grid; /* Keep grid */
            /* Precise mobile column widths for strict alignment and consistent sizing */
            grid-template-columns: minmax(80px, 1fr) 40px 120px; /* Adjusted last column from 85px to 120px */
            gap: 8px; /* Slightly reduced gap on mobile */
            align-items: center; /* Ensure vertical alignment */
        }
        /* Make inputs fill their grid columns on mobile and remove desktop max-width */
        .building-row input[id^="level"] {
            width: 100%;
            max-width: unset; /* Remove desktop fixed width constraints */
            font-size: 0.9em;
            padding: 5px; /* Smaller padding for mobile */
            text-align: right !important; /* Force right justification on mobile */
        }
        .building-row input[id^="resource"] {
            width: 100%;
            max-width: unset; /* Remove desktop fixed width constraints */
            font-size: 0.9em;
            padding: 5px; /* Smaller padding for mobile */
            text-align: right !important; /* Force right justification on mobile */
        }
        .building-row label {
            font-size: 0.9em;
            padding: 0; /* Remove padding if not needed */
        }

        .header-row {
            /* Match building-row on mobile for perfect alignment */
            grid-template-columns: minmax(80px, 1fr) 40px 120px; /* Adjusted last column from 85px to 120px */
            gap: 8px;
            font-size: 0.9em; /* Match building row labels */
        }

        /* Bottom controls on mobile - REVISED for alignment */
        #bottom-controls {
            flex-direction: row; /* Keep them in a row */
            justify-content: space-between; /* Push to left and right */
            align-items: center;
            gap: 10px; /* Space between them */
            margin-top: 15px;
            padding: 0 15px; /* Adjust padding to match container's inner padding */
            max-width: 95%; /* Limit overall width */
            box-sizing: border-box; /* Ensure padding is included in width */
            flex-wrap: nowrap; /* Prevent wrapping on mobile */
        }
        #language-selector-container {
            justify-content: flex-end; /* Push language selector to the right */
            width: auto; /* Allow content to dictate width */
            flex-shrink: 0; /* Prevent shrinking */
            /* Ensure alignment with theme toggle */
            display: flex; /* Explicitly set flex to ensure alignment */
            align-items: center; /* Vertically align with button */
        }
        #theme-toggle {
            align-self: center; /* Ensure vertical alignment to center */
            width: fit-content;
            padding: 6px 10px;
            font-size: 0.85em;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #instructions-button { /* Adjust for mobile if needed */
            font-size: 1.1em; /* Slightly smaller on mobile if desired */
            padding: 4px 8px; /* Adjusted padding */
        }


        .version-info {
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--text-color);
            text-align: center;
        }
    }
</style>
</head>
<body>

    <div class="container">
        <h2 data-i18n="title">Time Until Optoelectronic Lab Can Be Upgraded</h2>

        <div class="header-row">
            <span></span>
            <strong id="header-level" data-i18n="headerLevel">Level</strong>
            <strong id="header-held" data-i18n="headerHeld">Held</strong>
        </div>

        <div class="building-row">
            <label id="building1-name" data-i18n="resourceBuilding1">Quartz Workshop 1</label>
            <input type="tel" id="level1" value="" onblur="updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="2" aria-labelledby="building1-name header-level" maxlength="2">
            <input type="tel" id="resource1" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="7" aria-labelledby="building1-name header-held">
        </div>
        <div class="building-row">
            <label id="building2-name" data-i18n="resourceBuilding2">Quartz Workshop 2</label>
            <input type="tel" id="level2" value="" onblur="updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="3" aria-labelledby="building2-name header-level" maxlength="2">
            <input type="tel" id="resource2" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="8" aria-labelledby="building2-name header-held">
        </div>
        <div class="building-row">
            <label id="building3-name" data-i18n="resourceBuilding3">Quartz Workshop 3</label>
            <input type="tel" id="level3" value="" onblur="updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="4" aria-labelledby="building3-name header-level" maxlength="2">
            <input type="tel" id="resource3" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="9" aria-labelledby="building3-name header-held">
        </div>
        <div class="building-row">
            <label id="building4-name" data-i18n="resourceBuilding4">Quartz Workshop 4</label>
            <input type="tel" id="level4" value="" onblur="updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="5" aria-labelledby="building4-name header-level" maxlength="2">
            <input type="tel" id="resource4" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="10" aria-labelledby="building4-name header-held">
        </div>
        <div class="building-row">
            <label id="weeklyBuilding-name" data-i18n="weeklyBuilding">Weekly Workshop</label>
            <input type="tel" id="levelWeekly" value="" onblur="updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="6" aria-labelledby="weeklyBuilding-name header-level" maxlength="2">
            <input type="tel" id="resourceWeekly" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="11" aria-labelledby="weeklyBuilding-name header-held">
        </div>

        <hr>

        <div class="row">
            <span class="display-label" data-i18n="resourcePerHour">Quartz/hr:</span>
            <span id="resourceHrDisplay" class="display-value">0</span>
        </div>

        <div class="row">
            <label for="resourceHeldText" data-i18n="resourceHeld">Quartz Held:</label>
            <input type="tel" id="resourceHeldText" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="12">
        </div>

        <div class="row">
            <span class="display-label" data-i18n="totalResource">Total Quartz:</span>
            <span id="totalResourceDisplay" class="display-value">0</span>
        </div>

        <div class="row">
            <label for="resourceNeededText" data-i18n="resourceNeeded">Quartz Needed:</label>
            <input type="tel" id="resourceNeededText" value="" onblur="expandDecimal(this); updateCalculations(this); formatInput(this)" onfocus="this.select()" tabindex="13">
        </div>

        <div class="row">
            <span class="display-label" data-i18n="timeToComplete">Time to Complete:</span>
            <span id="timeDisplay" class="display-value">N/A</span>
        </div>

        <div class="row">
            <span class="display-label" data-i18n="completionTime">Completion Time:</span>
            <span id="completionTimeDisplay" class="display-value">N/A</span>
        </div>

        <div class="row">
            <label for="timezoneSelect" data-i18n="displayTimeZone">Display Time Zone:</label>
            <select id="timezoneSelect" onchange="updateCalculations()" tabindex="14">
                </select>
        </div>
    </div>

    <div id="bottom-controls">
        <button id="theme-toggle" tabindex="15">Toggle Theme</button>
        <button id="instructions-button" tabindex="16" aria-label="Instructions">❓</button>
        <div id="language-selector-container">
            <label for="languageSelect">Language:</label>
            <select id="languageSelect" tabindex="1">
                </select>
        </div>
    </div>

    <div class="version-info">
        Version 4.2.4 - Last Updated: June 13, 2025, 10:53 PM EDT
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" aria-label="Close Instructions">&times;</button>
            <h3 id="modal-title" data-i18n="directionsTitle">Directions for Use</h3>
            <div id="modal-text-content">
                <!-- Instructions will be dynamically loaded here -->
            </div>
        </div>
    </div>

    <script>
        // These constants will be dynamically set by setGlobalConstantsForLanguage()
        let BUILDING_NAME = '';
        let RESOURCE_NAME = '';
        let BUILDING_TYPE = '';

        // Define your translations
        const translations = {
            'en': { // English (default fallback)
                buildingName: 'Optoelectronic Lab',
                resourceName: 'Quartz',
                buildingType: 'Workshop',
                title: `Time Until {buildingName} Can Be Upgraded`, // Placeholder to be replaced
                headerLevel: 'Level',
                headerHeld: 'Held',
                resourceBuilding1: `{resourceName} {buildingType} 1`,
                resourceBuilding2: `{resourceName} {buildingType} 2`,
                resourceBuilding3: `{resourceName} {buildingType} 3`,
                resourceBuilding4: `{resourceName} {buildingType} 4`,
                weeklyBuilding: `Weekly {buildingType}`,
                resourcePerHour: `{resourceName}/hr:`,
                resourceHeld: `{resourceName} Held:`,
                totalResource: `Total {resourceName}:`,
                resourceNeeded: `Required {resourceName}:`, // Changed from 'Quartz Needed' to 'Required Quartz' for clarity
                timeToComplete: 'Time to Complete:',
                timeRemainingFormat: '{hours} hrs', // New: "X hrs"
                timeAgoFormat: '{hours} hrs ago',    // New: "X hrs ago"
                completionTime: 'Completion Time:',
                displayTimeZone: 'Display Time Zone:',
                toggleTheme: 'Toggle Theme', // New translation for the button
                directionsTitle: 'Directions for Use', // New modal title translation
                directionsText: [ // New modal content translation
                    'To effectively use the {buildingName} Upgrade Calculator, please follow these steps:',
                    '1. **Enter {buildingType} Levels:** Begin by inputting the current level for each individual {resourceName} {buildingType} (e.g., "{resourceName} {buildingType} 1", "{resourceName} {buildingType} 2", etc.).',
                    '2. **Input {resourceName} Held in {buildingType}s:** Next, enter the amount of {resourceName} currently held in the "bubbles" above each of your {buildingType}s. Note that the calculator will automatically **auto-fill empty fields** for any other {buildingType}s that are at the **same level** as the one you just entered. You can **still manually edit these fields** if those buildings are holding a different amount.',
                    '3. **Specify Lab {resourceName} Values:** Finally, input the amount of {resourceName} you currently **hold** in your main inventory (directly under "{resourceName} Held") and the **total amount of {resourceName} needed** for the next {buildingName} upgrade (under "{resourceName} Needed").',
                    'This calculator is designed to be fully functional offline, so you can use it anytime, anywhere without an internet connection.'
                ]
            },
            'es': { // Spanish
                buildingName: 'Laboratorio Optoelectrónico',
                resourceName: 'Cuarzo',
                buildingType: 'Taller',
                title: `Tiempo hasta que el {buildingName} pueda ser mejorado`,
                headerLevel: 'Nivel',
                headerHeld: 'Obtenido',
                resourceBuilding1: `{resourceName} {buildingType} 1`,
                resourceBuilding2: `{resourceName} {buildingType} 2`,
                resourceBuilding3: `{resourceName} {buildingType} 3`,
                resourceBuilding4: `{resourceName} {buildingType} 4`,
                weeklyBuilding: `Semanal {buildingType}`,
                resourcePerHour: `Cuarzo/hora:`,
                resourceHeld: `Cuarzo Actual:`,
                totalResource: `Cuarzo Total:`,
                resourceNeeded: `Cuarzo Requerido:`, // Changed from 'Cuarzo Necesario' to 'Cuarzo Requerido' for clarity
                timeToComplete: 'Tiempo Restante:',
                timeRemainingFormat: '{hours} h', // New: "X h"
                timeAgoFormat: 'hace {hours} h',    // New: "hace X h"
                completionTime: 'Hora de Finalización:',
                displayTimeZone: 'Zona Horaria:',
                toggleTheme: 'Cambiar Tema',
                directionsTitle: 'Instrucciones de Uso',
                directionsText: [
                    'Para usar eficazmente la Calculadora de Mejoras del {buildingName}, siga estos pasos:',
                    '1. **Introduzca los niveles de {buildingType}:** Comience ingresando el nivel actual para cada {buildingType} de {resourceName} individual (por ejemplo, "{resourceName} {buildingType} 1", "{resourceName} {buildingType} 2", etc.).',
                    '2. **Introduzca el {resourceName} Obtenido en los {buildingType}s:** A continuación, introduzca la cantidad de {resourceName} que se encuentra actualmente en las "burbujas" encima de cada uno de sus {buildingType}s. Tenga en cuenta que la calculadora rellenará automáticamente los **campos vacíos** de {resourceName} para cualquier otro {buildingType} que esté en el **mismo nivel** que el que acaba de introducir. Puede **seguir editando estos campos manualmente** si esos edificios tienen una cantidad diferente.',
                    '3. **Especifique los Valores de {resourceName} del Laboratorio:** Finalmente, introduzca la cantidad de {resourceName} que **tiene actualmente** en su inventario principal (dirección debajo de "{resourceName} Actual") y la **cantidad total de {resourceName} necesaria** para la próxima mejora del {buildingName} (debajo de "{resourceName} Necesario").',
                    'Esta calculadora está diseñada para ser completamente funcional sin conexión, por lo que puede usarla en cualquier momento y lugar sin necesidad de una conexión a Internet.'
                ]
            },
            'pt': { // Portuguese
                buildingName: 'Laboratório Optoeletrônico',
                resourceName: 'Quartzo',
                buildingType: 'Oficina',
                title: `Tempo até o {buildingName} Poder Ser Atualizado`,
                headerLevel: 'Nivel',
                headerHeld: 'Tido',
                resourceBuilding1: `{buildingType} de {resourceName} 1`,
                resourceBuilding2: `{buildingType} de {resourceName} 2`,
                resourceBuilding3: `{buildingType} de {resourceName} 3`,
                resourceBuilding4: `{buildingType} de {resourceName} 4`,
                weeklyBuilding: `Semanal {buildingType}`,
                resourcePerHour: `Quartzo/hr:`,
                resourceHeld: `Quartzo Atual:`,
                totalResource: `Quartzo Total:`,
                resourceNeeded: `Quartzo Requerido:`, // Changed from 'Quartzo Necessário' to 'Quarzo Requerido' for clarity
                timeToComplete: 'Tempo para Concluir:',
                timeRemainingFormat: '{hours} h', // New: "X h"
                timeAgoFormat: 'há {hours} h',    // New: "há X h"
                completionTime: 'Hora de Conclusão:',
                displayTimeZone: 'Fuso Horário:',
                toggleTheme: 'Alternar Tema',
                directionsTitle: 'Instruções de Uso',
                directionsText: [
                    'Para usar eficazmente a Calculadora de Melhorias do {buildingName}, siga estes passos:',
                    '1. **Introduza os Níveis da {buildingType}:** Comece por inserir o nível actual para cada {buildingType} de {resourceName} individual (ex: "{resourceName} {buildingType} 1", "{resourceName} {buildingType} 2", etc.).',
                    '2. **Introduza o {resourceName} Detido nas {buildingType}s:** Em seguida, introduza a quantidade de {resourceName} actualmente detida nas "bolhas" acima de cada uma das suas {buildingType}s. Note que a calculadora preencherá automaticamente os **campos vazios** de {resourceName} detido para quaisquer outras {buildingType}s que estejam no **mesmo nível** que a que acabou de introduzir. Pode **continuar a editar estes campos manualmente** se esses edifícios tiverem uma quantidade diferente.',
                    '3. **Especifique os Valores de {resourceName} do Laboratório:** Finalmente, introduza a quantidade de {resourceName} que **detém actualmente** no seu inventario principal (directamente abaixo de "{resourceName} Actual") y la **quantidade total de {resourceName} necessária** para la próxima melhoria do {buildingName} (abajo de "{resourceName} Necessário").',
                    'Esta calculadora foi concebida para ser totalmente funcional offline, para que possa utilizá-la a qualquer hora, em qualquer lugar, sem ligação à Internet.'
                ]
            },
            'ko': { // Korean
                buildingName: '광전자 연구소',
                resourceName: '석영',
                buildingType: '작업장',
                title: `{buildingName} 업그레이드까지 남은 시간`,
                headerLevel: '레벨',
                headerHeld: '보유',
                resourceBuilding1: `{resourceName} {buildingType} 1`,
                resourceBuilding2: `{resourceName} {buildingType} 2`,
                resourceBuilding3: `{resourceName} {buildingType} 3`,
                resourceBuilding4: `{resourceName} {buildingType} 4`,
                weeklyBuilding: `주간 {buildingType}`,
                resourcePerHour: `시간당 {resourceName}:`,
                resourceHeld: `보유 {resourceName}:`,
                totalResource: `총 {resourceName}:`,
                resourceNeeded: `필요한 {resourceName}:`,
                timeToComplete: '완료까지 남은 시간:',
                timeRemainingFormat: '{hours}시간', // New: "X시간"
                timeAgoFormat: '{hours}시간 전',    // New: "X시간 전"
                completionTime: '완료 시간:',
                displayTimeZone: '표시 시간대:',
                toggleTheme: '테마 전환',
                directionsTitle: '사용 방법',
                directionsText: [
                    `{buildingName} 업그레이드 계산기를 효과적으로 사용하려면 다음 단계를 따르세요:`,
                    `1. **{buildingType} 레벨 입력:** 먼저 각 개별 {resourceName} {buildingType}(예: "{resourceName} {buildingType} 1", "{resourceName} {buildingType} 2" 등)의 현재 레벨을 입력합니다.`,
                    `2. **{buildingType}에 보유한 {resourceName} 입력:** 다음으로, 각 {buildingType} "버블" 위에 현재 보유하고 있는 {resourceName}의 양을 입력합니다. 계산기는 방금 입력한 {buildingType}과 **동일한 레벨**의 다른 모든 {buildingType}에 대해 **비어 있는 필드**에 보유 {resourceName}를 자동으로 **자동 채우기**합니다. 이러한 필드에 다른 양이 있는 경우 **계속 수동으로 편집할 수 있습니다.**`,
                    `3. **연구소 {resourceName} 값 지정:** 마지막으로, 메인 인벤토리({resourceName} 보유" 바로 아래)에 현재 **보유하고 있는 {resourceName}의 양과 다음 {buildingName} 업그레이드에 필요한 총 {resourceName} 양({resourceName} 필요" 아래)을 입력합니다.`,
                    `この計算機はオフラインでも完全に機能するように設計되었으므로、インターネット接続なしでいつでもどこでも使用できます。`
                ]
            },
            'ja': { // Japanese
                buildingName: '光電子研究所',
                resourceName: '石英',
                buildingType: '作業場',
                title: `{buildingName} アップグレードまでの時間`,
                headerLevel: 'レベル',
                headerHeld: '所持',
                resourceBuilding1: `{resourceName} {buildingType} 1`,
                resourceBuilding2: `{resourceName} {buildingType} 2`,
                resourceBuilding3: `{resourceName} {buildingType} 3`,
                resourceBuilding4: `{resourceName} {buildingType} 4`,
                weeklyBuilding: `週次 {buildingType}`,
                resourcePerHour: `{resourceName}/時:`,
                resourceHeld: `所持{resourceName}:`,
                totalResource: `合計{resourceName}:`,
                resourceNeeded: `必要な{resourceName}:`,
                timeToComplete: '完了までの時間:',
                timeRemainingFormat: '{hours}時間', // New: "X時間"
                timeAgoFormat: '{hours}時間前',    // New: "X時間前"
                completionTime: '完了時刻:',
                displayTimeZone: '表示タイムゾーン:',
                toggleTheme: 'テーマ切り替え',
                directionsTitle: '使用方法',
                directionsText: [
                    `{buildingName} アップグレード計算機を効果的に使用するには、以下の手順に従ってください:`,
                    `1. **{buildingType}レベルの入力:** まず、各{resourceName} {buildingType}(例: "{resourceName} {buildingType} 1"、"{resourceName} {buildingType} 2" など) の現在のレベルを入力します。`,
                    `2. **{buildingType}に保持されている{resourceName}の入力:** 次に、各{buildingType}の「泡」に現在保持されている{resourceName}の量を入力します。計算機は、入力した{resourceName}と**同じレベル**の他のすべての{buildingType}に対して、**空のフィールド**に{resourceName}の保持量を自動的に**自動入力**することに注意してください。これらのフィールドに異なる量がある場合は、**引き続き手動で編集できます。**`,
                    `3. **ラボの{resourceName}値の指定:** 最後に、現在メインインベントリ (「所持{resourceName}」の真下) に**保持している{resourceName}の量**と、次の{buildingName}アップグレードに**必要な合計{resourceName}量** (「必要な{resourceName}」の下) を入力します。`,
                    `この計算機はオフラインでも完全に機能するように設計되었으므로、インターネット接続なしでいつでもどこでも使用できます。`
                ]
            }
        };


        /**
         * Dynamically sets the global constants (BUILDING_NAME, RESOURCE_NAME, BUILDING_TYPE)
         * based on the currently selected or detected language.
         * This must run BEFORE applyTranslations to ensure template literals are correctly resolved.
         */
        function setGlobalConstantsForLanguage(langToUse) {
            const currentTranslations = translations[langToUse] || translations['en'];
            BUILDING_NAME = currentTranslations.buildingName;
            RESOURCE_NAME = currentTranslations.resourceName;
            BUILDING_TYPE = currentTranslations.buildingType;
        }

        // Function to apply translations based on a specified language or auto-detect
        function applyTranslations(langOverride = null) {
            let langToUse;

            if (langOverride) {
                langToUse = langOverride;
            } else if (document.getElementById('languageSelect') && document.getElementById('languageSelect').value) {
                langToUse = document.getElementById('languageSelect').value;
            } else {
                langToUse = navigator.language.split('-')[0];
            }

            // Ensure the language code exists in our translations, fallback to 'en'
            langToUse = translations[langToUse] ? langToUse : 'en';

            // Set global constants for the chosen language BEFORE applying translations
            setGlobalConstantsForLanguage(langToUse);

            // Now, get the translations for the chosen language.
            // We'll create a temporary object to hold the fully processed strings.
            const processedTranslations = {};
            const currentTranslationsSource = translations[langToUse];

            // Process each translation string to replace placeholders with dynamic global constants
            for (const key in currentTranslationsSource) {
                if (currentTranslationsSource.hasOwnProperty(key)) {
                    let value = currentTranslationsSource[key];
                    if (Array.isArray(value)) { // Handle arrays (like directionsText)
                        value = value.map(item => {
                            if (typeof item === 'string') {
                                item = item.replace(/{buildingName}/g, BUILDING_NAME);
                                item = item.replace(/{resourceName}/g, RESOURCE_NAME);
                                item = item.replace(/{buildingType}/g, BUILDING_TYPE);
                            }
                            return item;
                        });
                    } else if (typeof value === 'string') {
                        value = value.replace(/{buildingName}/g, BUILDING_NAME);
                        value = value.replace(/{resourceName}/g, RESOURCE_NAME);
                        value = value.replace(/{buildingType}/g, BUILDING_TYPE);
                    }
                    processedTranslations[key] = value;
                }
            }

            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect && languageSelect.value !== langToUse) {
                languageSelect.value = langToUse;
            }

            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                // Do not update dynamic display elements here, as they are updated by updateCalculations
                // This prevents overwriting of numeric values or 'X hrs ago' text
                if (key === 'timeRemainingFormat' || key === 'timeAgoFormat' || key === 'directionsText') {
                    return; // These are templates used by JS, not direct textContent (except for directionsText which needs special handling)
                }
                if (processedTranslations[key]) {
                    // If the element is the title tag, update document.title
                    if (element.tagName.toLowerCase() === 'title') {
                        document.title = processedTranslations[key];
                    } else {
                        element.textContent = processedTranslations[key];
                    }
                }
            });

            // Ensure the h2 element is updated (it also has data-i18n="title")
            const h2Element = document.querySelector('h2[data-i18n="title"]');
            if (h2Element && processedTranslations.title) {
                h2Element.textContent = processedTranslations.title;
            }

            // Update the theme toggle button text
            const themeToggleButton = document.getElementById('theme-toggle');
            if (themeToggleButton && processedTranslations.toggleTheme) {
                themeToggleButton.textContent = processedTranslations.toggleTheme;
            }

            // Update modal title explicitly
            const modalTitleElement = document.getElementById('modal-title');
            if (modalTitleElement && processedTranslations.directionsTitle) {
                modalTitleElement.textContent = processedTranslations.directionsTitle;
            }

            // Update modal text content
            const modalTextContentElement = document.getElementById('modal-text-content');
            if (modalTextContentElement && processedTranslations.directionsText) {
                modalTextContentElement.innerHTML = ''; // Clear previous content
                processedTranslations.directionsText.forEach(paragraph => {
                    const p = document.createElement('p');
                    // Replace markdown bold with HTML strong tag
                    p.innerHTML = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    modalTextContentElement.appendChild(p);
                });
            }
        }

        // Function to populate the language selection dropdown
        function populateLanguageSelector() {
            const languageSelect = document.getElementById('languageSelect');
            languageSelect.innerHTML = '';

            const languageNames = {
                'en': 'English',
                'es': 'Español',
                'pt': 'Português',
                'ko': '한국어',
                'ja': '日本語'
            };

            for (const langCode in translations) {
                if (translations.hasOwnProperty(langCode)) {
                    const option = document.createElement('option');
                    option.value = langCode;
                    option.textContent = languageNames[langCode] || langCode;
                    languageSelect.appendChild(option);
                }
            }

            const userBrowserLang = navigator.language.split('-')[0];
            if (languageSelect.querySelector(`option[value="${userBrowserLang}"]`)) {
                languageSelect.value = userBrowserLang;
            } else {
                languageSelect.value = 'en';
            }

            languageSelect.addEventListener('change', (event) => {
                applyTranslations(event.target.value);
                updateCalculations();
            });
        }

        // ######################### Helper Functions #########################
        const MAX_ALLOWED_RESOURCE = 99999999999; // Cap at 99 Billion

        /**
         * Expands a decimal number like 6.8 to 6800 or 102. to 102000 for 'resource' input fields.
         * Modifies the inputElement.value directly.
         */
        function expandDecimal(inputElement) {
            if (!inputElement.id.startsWith('resource')) {
                return;
            }

            let rawValue = inputElement.value.replace(/,/g, ''); // Remove commas
            let num = parseFloat(rawValue);

            if (isNaN(num)) {
                return; // Not a valid number, do nothing
            }

            // Trigger expansion ONLY if a decimal point was explicitly typed by the user
            if (rawValue.includes('.')) {
                // Case 1: Number with a non-zero fractional part (e.g., "6.8" -> 6800)
                if (num % 1 !== 0) {
                    inputElement.value = Math.round(num * 1000).toString();
                }
                // Case 2: Decimal point exists, but fractional part is zero or implied zero (e.g., "102." or "102.0" -> 102000)
                else {
                    inputElement.value = Math.round(num * 1000).toString();
                }
            }
            // If no decimal point is present (e.g., "102"), do NOT expand. It remains "102".
        }

        /**
         * Formats a number input with thousands separators and applies max value cap.
         */
        function formatInput(inputElement) {
            let value = inputElement.value.replace(/[^0-9.]/g, ''); // Remove non-numeric except dot
            if (value === '') {
                inputElement.value = '';
                return;
            }
            let number = parseFloat(value);
            if (isNaN(number)) {
                inputElement.value = '';
                return;
            }

            // Apply max value cap
            if (number > MAX_ALLOWED_RESOURCE) {
                number = MAX_ALLOWED_RESOURCE;
                // Update the actual input value if it was truncated
                // We'll let toLocaleString format it for display
                inputElement.value = number.toString();
            }

            // Determine if it should display decimals.
            // For resource amounts, we typically want no decimals for large numbers after expansion,
            // but inputs like 'resourceHeldText' can still display decimals for direct input.
            if (number % 1 === 0) { // It's a whole number
                inputElement.value = number.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            } else { // It has a fractional part
                // Limit decimals to 2 for display, but keep full number for internal calculations
                inputElement.value = number.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
            }
        }

        // Function to get a cleaned number from a textbox (removes commas)
        function getCleanNumber(id) {
            const inputElement = document.getElementById(id);
            if (!inputElement) return 0;
            const value = inputElement.value.replace(/,/g, ''); // Remove commas for calculation
            return parseFloat(value) || 0;
        }

        // ######################### Time Zone Logic #########################

        // Curated list of time zones with their explicit IDs and display logic.
        // `observesDst`: boolean indicating if the timezone observes Daylight Saving Time.
        // `standardOffset`: The standard offset from UTC in hours (used as fallback).
        // `baseDisplayName`: The primary name for the timezone (e.g., "Eastern Time", "Hawaii Standard Time").
        // `customDisplayString`: If present, this string will be used exactly for the dropdown option,
        //                        overriding Intl.DateTimeFormat and other logic.
        // `customAbbreviation`: If present, this abbreviation will be used for the completion time,
        //                       overriding Intl.DateTimeFormat 'short' name and other logic.
        const curatedTimezones = [
            // UTC always comes first
            { id: "Etc/UTC", observesDst: false, standardOffset: 0, baseDisplayName: "Coordinated Universal Time", customAbbreviation: "UTC" },

            // Time zones that observe DST - will dynamically show "Standard" or "Daylight"
            // `baseDisplayName` is a fallback if Intl.DateTimeFormat doesn't provide a good long name.
            { id: "Europe/London", observesDst: true, standardOffset: 0, baseDisplayName: "British Time", customAbbreviation: null },
            { id: "Europe/Berlin", observesDst: true, standardOffset: 1, baseDisplayName: "Central European Time", customAbbreviation: null },
            { id: "Africa/Cairo", observesDst: true, standardOffset: 2, baseDisplayName: "Eastern European Time", customAbbreviation: null },
            { id: "Australia/Sydney", observesDst: true, standardOffset: 10, baseDisplayName: "Australian Eastern Time", customAbbreviation: null },
            { id: "Pacific/Fiji", observesDst: true, standardOffset: 12, baseDisplayName: "Fiji Time", customAbbreviation: null },
            { id: "Pacific/Auckland", observesDst: true, standardOffset: 12, baseDisplayName: "New Zealand Time", customAbbreviation: null },
            { id: "America/St_Johns", observesDst: true, standardOffset: -3.5, baseDisplayName: "Newfoundland Time", customAbbreviation: null },
            { id: "America/Halifax", observesDst: true, standardOffset: -4, baseDisplayName: "Atlantic Time", customAbbreviation: null },
            { id: "America/New_York", observesDst: true, standardOffset: -5, baseDisplayName: "Eastern Time", customAbbreviation: null },
            { id: "America/Chicago", observesDst: true, standardOffset: -6, baseDisplayName: "Central Time", customAbbreviation: null },
            { id: "America/Denver", observesDst: true, standardOffset: -7, baseDisplayName: "Mountain Time", customAbbreviation: null },
            { id: "America/Los_Angeles", observesDst: true, standardOffset: -8, baseDisplayName: "Pacific Time", customAbbreviation: null },
            { id: "America/Anchorage", observesDst: true, standardOffset: -9, baseDisplayName: "Alaska Time", customAbbreviation: null },

            // Time zones that do NOT observe DST - will always show "Standard Time" (Intl will often provide this)
            // `baseDisplayName` for these entries should already include "Standard Time" or be a name that naturally implies it.
            { id: "Europe/Moscow", observesDst: false, standardOffset: 3, baseDisplayName: "Moscow Standard Time", customAbbreviation: "MSK" },
            { id: "Asia/Dubai", observesDst: false, standardOffset: 4, baseDisplayName: "Gulf Standard Time", customAbbreviation: "GST" },
            { id: "Asia/Karachi", observesDst: false, standardOffset: 5, baseDisplayName: "Pakistan Standard Time", customAbbreviation: "PKT" },
            { id: "Asia/Kolkata", observesDst: false, standardOffset: 5.5, baseDisplayName: "India Standard Time", customAbbreviation: "IST" },
            { id: "Asia/Dhaka", observesDst: false, standardOffset: 6, baseDisplayName: "Bangladesh Standard Time", customAbbreviation: "BST" },
            { id: "Asia/Bangkok", observesDst: false, standardOffset: 7, baseDisplayName: "Indochina Time", customAbbreviation: "ICT" },
            { id: "Asia/Shanghai", observesDst: false, standardOffset: 8, baseDisplayName: "China Standard Time", customAbbreviation: "CST" },
            { id: "Asia/Tokyo", observesDst: false, standardOffset: 9, baseDisplayName: "Japan Standard Time", customAbbreviation: "JST" },
            { id: "Pacific/Guam", observesDst: false, standardOffset: 10, baseDisplayName: "Chamorro Standard Time", customAbbreviation: "ChST" },
            { id: "Pacific/Noumea", observesDst: false, standardOffset: 11, baseDisplayName: "New Caledonia Time", customAbbreviation: "NCT" },
            { id: "Pacific/Kiritimati", observesDst: false, standardOffset: 14, baseDisplayName: "Line Islands Time", customAbbreviation: "LINT" },
            { id: "America/Honolulu", observesDst: false, standardOffset: -10, baseDisplayName: "Hawaii Standard Time", customAbbreviation: "HST" },
            { id: "Pacific/Pago_Pago", observesDst: false, standardOffset: -11, baseDisplayName: "Samoa Standard Time", customAbbreviation: "SST" },

            // Special cases with explicitly defined custom display strings and abbreviations
            { id: "America/Indiana/Indianapolis", observesDst: false, standardOffset: -5, customDisplayString: "Indiana (Eastern Standard Time) (No DST)", customAbbreviation: "EST" },
            { id: "America/Phoenix", observesDst: false, standardOffset: -7, customDisplayString: "Arizona (Mountain Standard Time) (No DST)", customAbbreviation: "MST" },
            { id: "Australia/Brisbane", observesDst: false, standardOffset: 10, customDisplayString: "Brisbane (Australian Eastern Standard Time) (No DST)", customAbbreviation: "AEST" }
        ];


        /**
         * Dynamically calculates the numerical offset in hours for a given timezone ID
         * relative to UTC, at a specific Date.
         * Includes a robust fallback to predefined standard offsets if Intl.DateTimeFormat unexpectedly fails.
         * @param {string} tzId - The IANA timezone ID (e.g., "America/New_York").
         * @param {Date} date - The Date object at which to calculate the offset.
         * @returns {number} The offset in hours from UTC. Returns the standardOffset as fallback on error.
         */
        function getNumericalOffsetInHours(tzId, date = new Date()) {
            // Hardcoded offset for Hawaii Standard Time as per user request to ensure consistency
            if (tzId === "America/Honolulu") {
                return -10;
            }

            // First, try to get the dynamic offset using Intl.DateTimeFormat
            try {
                const targetLocaleTime = new Date(date.toLocaleString('en-US', {
                    timeZone: tzId,
                    year: 'numeric', month: 'numeric', day: 'numeric',
                    hour: 'numeric', minute: 'numeric', second: '2-digit',
                    hourCycle: 'h23'
                })).getTime();

                const utcTime = new Date(date.toLocaleString('en-US', {
                    timeZone: 'Etc/UTC',
                    year: 'numeric', month: 'numeric', day: 'numeric',
                    hour: 'numeric', minute: 'numeric', second: '2-digit',
                    hourCycle: 'h23'
                })).getTime();

                return (targetLocaleTime - utcTime) / (1000 * 60 * 60);

            } catch (e) {
                console.error(`Error calculating dynamic offset for timezone '${tzId}' at date ${date.toISOString()}: ${e.message}. Attempting fallback.`);

                // Fallback 1: Use the predefined standardOffset from curatedTimezones
                const curatedEntry = curatedTimezones.find(tz => tz.id === tzId);
                if (curatedEntry && typeof curatedEntry.standardOffset === 'number') {
                    console.log(`Falling back to predefined standard offset for '${tzId}': ${curatedEntry.standardOffset}.`);
                    return curatedEntry.standardOffset;
                }

                // Fallback 2: Last resort - use the browser's current local offset (least accurate if tzId is not local)
                console.warn(`No specific standard offset found for '${tzId}'. Falling back to browser's local offset.`);
                return date.getTimezoneOffset() / -60;
            }
        }

        /**
         * Attempts to get a short timezone abbreviation (e.g., "EST", "EDT", "HST").
         * Prioritizes custom definitions, then dynamic DST detection for common zones,
         * then Intl.DateTimeFormat, then infers from base display name, finally falls back to UTC offset.
         * @param {string} tzId - The IANA timezone ID.
         * @param {Date} date - The date to check for DST.
         * @param {number} offsetHours - The numerical UTC offset (pre-calculated), used for final fallback.
         * @returns {string} The short abbreviation or formatted UTC offset.
         */
        function getShortTimeZoneAbbreviation(tzId, date, offsetHours) {
            const tzData = curatedTimezones.find(tz => tz.id === tzId);

            // Priority 1: Custom abbreviation explicitly defined in curatedTimezones
            if (tzData && tzData.customAbbreviation) {
                return tzData.customAbbreviation;
            }

            // Priority 2: Dynamic abbreviations for common DST zones (US/Canada/UK/Europe/Australia/Cairo)
            // Determine if DST is active for the given date in the specific timezone
            let isDst = false;
            if (tzData && tzData.observesDst) {
                try {
                    // Compare the current offset to the standard offset to infer DST
                    const currentOffset = getNumericalOffsetInHours(tzId, date);
                    isDst = (currentOffset !== tzData.standardOffset);
                } catch (e) {
                    console.warn(`Could not reliably determine DST for ${tzId} using offset comparison: ${e.message}`);
                }
            }
            
            switch (tzId) {
                case "America/New_York": return isDst ? "EDT" : "EST";
                case "America/Chicago": return isDst ? "CDT" : "CST";
                case "America/Denver": return isDst ? "MDT" : "MST";
                case "America/Los_Angeles": return isDst ? "PDT" : "PST";
                case "America/Anchorage": return isDst ? "AKDT" : "AKST";
                case "America/Halifax": return isDst ? "ADT" : "AST";
                case "Europe/London": return isDst ? "BST" : "GMT";
                case "Europe/Berlin": return isDst ? "CEST" : "CET";
                case "Africa/Cairo": return isDst ? "EEST" : "EET";
                case "Australia/Sydney": return isDst ? "AEDT" : "AEST"; // AEDT for Daylight, AEST for Standard
            }

            // Priority 3: Try to get the short time zone name using Intl.DateTimeFormat (as before)
            let abbreviation = '';
            try {
                const formatter = new Intl.DateTimeFormat('en-US', { timeZone: tzId, timeZoneName: 'short' });
                const formattedParts = formatter.formatToParts(date);
                const timeZoneNamePart = formattedParts.find(p => p.type === 'timeZoneName');

                if (timeZoneNamePart && timeZoneNamePart.value && timeZoneNamePart.value.trim() !== '') {
                    const value = timeZoneNamePart.value;
                    // Filter out generic GMT/UTC/numeric offsets that Intl.DateTimeFormat sometimes provides as 'short' names
                    if (!value.startsWith('GMT') && !value.startsWith('UTC') && !/^[+-]\d{1,2}(:\d{2})?$/.test(value)) {
                        abbreviation = value;
                    }
                }
            } catch (e) {
                console.warn(`Could not get short time zone abbreviation for '${tzId}' via Intl.DateTimeFormat: ${e.message}.`);
            }

            // Priority 4: Infer from baseDisplayName if Intl still failed
            if (!abbreviation && tzData && tzData.baseDisplayName) {
                let base = tzData.baseDisplayName;
                // This is less reliable for common abbreviations but helps for less common ones
                if (base.includes("Standard Time")) {
                    abbreviation = base.replace("Standard Time", "ST").replace(/\s/g, '');
                } else if (base.includes("Daylight Time")) {
                    abbreviation = base.replace("Daylight Time", "DT").replace(/\s/g, '');
                } else if (base.includes("Time")) {
                    abbreviation = base.replace(/Time$/, '').replace(/\s/g, '');
                }
            }
            
            // Final Fallback: Generic UTC offset format
            if (!abbreviation) {
                const offsetSign = offsetHours >= 0 ? '+' : '-';
                const absOffsetHours = Math.abs(offsetHours);
                const integerHours = Math.floor(absOffsetHours);
                const fractionalMinutes = Math.round((absOffsetHours % 1) * 60);

                let formattedOffset = `UTC${offsetSign}${integerHours.toString()}`;
                if (fractionalMinutes > 0) {
                    formattedOffset += `:${fractionalMinutes.toString().padStart(2, '0')}`;
                }
                abbreviation = formattedOffset;
            }
            return abbreviation;
        }


        function populateTimezones() {
            const timezoneSelect = document.getElementById('timezoneSelect');
            const now = new Date(); // Use current date for calculating offsets and names for dropdown population
            const localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone; // Get actual local browser timezone ID

            timezoneSelect.innerHTML = ''; // Clear existing options

            const tempOptions = []; // To store options before sorting

            curatedTimezones.forEach(tzData => {
                const offsetHours = getNumericalOffsetInHours(tzData.id, now);
                
                // Format the offset for display (e.g., UTC-05:00, UTC+09)
                const offsetSign = offsetHours >= 0 ? '+' : '-';
                const absOffsetHours = Math.abs(offsetHours);
                const integerHours = Math.floor(absOffsetHours);
                const fractionalMinutes = Math.round((absOffsetHours % 1) * 60);

                let formattedOffset = `UTC${offsetSign}${integerHours.toString()}`;
                if (fractionalMinutes > 0) {
                    formattedOffset += `:${fractionalMinutes.toString().padStart(2, '0')}`;
                }

                let finalDisplayName;

                if (tzData.customDisplayString) {
                    // Use the predefined custom string if available
                    finalDisplayName = tzData.customDisplayString;
                } else {
                    let intlLongName = '';
                    try {
                        const longNameFormatter = new Intl.DateTimeFormat('en-US', {
                            timeZone: tzData.id,
                            timeZoneName: 'long'
                        });
                        const longNameParts = longNameFormatter.formatToParts(now);
                        const longTimeZoneNamePart = longNameParts.find(p => p.type === 'timeZoneName');
                        if (longTimeZoneNamePart && longTimeZoneNamePart.value && longTimeZoneNamePart.value.trim() !== '') {
                            const val = longTimeZoneNamePart.value;
                            // Only use Intl's name if it's descriptive and not a generic offset like "GMT-X"
                            if (!val.startsWith('GMT') && !val.startsWith('UTC') && !/^[+-]\d{1,2}(:\d{2})?$/.test(val)) {
                                intlLongName = val;
                            }
                        }
                    } catch (e) {
                        // Intl.DateTimeFormat can sometimes fail for various reasons; proceed with fallbacks.
                    }

                    // Use Intl's name if it's descriptive, otherwise fall back to our baseDisplayName
                    let coreName = intlLongName || tzData.baseDisplayName;

                    // Ensure "Standard Time" for non-DST zones if not already present in Intl's name
                    // and if the baseDisplayName doesn't inherently cover it (like "New Caledonia Time")
                    if (!tzData.observesDst && coreName !== "Coordinated Universal Time") {
                        if (!coreName.toLowerCase().includes("standard time") && !coreName.toLowerCase().includes("time zone") && !coreName.toLowerCase().includes("time")) {
                            coreName += " Standard Time";
                        } else if (coreName.toLowerCase().endsWith("time") && !coreName.toLowerCase().includes("standard time")) {
                            // If it ends with "Time" but not "Standard Time", make it "Standard Time"
                            coreName = coreName.replace(/Time$/, 'Standard Time');
                        }
                    }
                    finalDisplayName = coreName;
                }
                
                // Construct the final display string: Name (UTC Offset)
                const displayString = `${finalDisplayName} (${formattedOffset})`;

                tempOptions.push({
                    id: tzData.id,
                    offset: offsetHours,
                    formattedDisplay: displayString
                });
            });

            // Sorting logic remains the same
            tempOptions.sort((a, b) => {
                if (a.offset !== b.offset) {
                    return a.offset - b.offset;
                }
                return a.formattedDisplay.localeCompare(b.formattedDisplay);
            });

            tempOptions.forEach(tzData => {
                const option = document.createElement('option');
                option.value = tzData.id;
                option.textContent = tzData.formattedDisplay;
                timezoneSelect.appendChild(option);
            });

            // Attempt to pre-select the user's local time zone or the closest match
            timezoneSelect.value = localTimeZone;
            if (timezoneSelect.value !== localTimeZone && tempOptions.length > 0) {
                const localOffset = getNumericalOffsetInHours(localTimeZone, now);
                let bestMatchIndex = 0;
                let minDiff = Infinity;

                for (let i = 0; i < tempOptions.length; i++) {
                    const diff = Math.abs(tempOptions[i].offset - localOffset);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestMatchIndex = i;
                    }
                }
                timezoneSelect.selectedIndex = bestMatchIndex;
                console.log(`Local timezone '${localTimeZone}' not directly in curated list. Defaulting to closest offset: '${tempOptions[bestMatchIndex].formattedDisplay}'.`);
            }
        }


        // ######################### Main Calculation Logic #########################
        /**
         * Performs calculations and handles auto-population of resource held values.
         * @param {HTMLElement} [triggeringElement=null] - The input element that triggered the update (e.g., onblur).
         */
        function updateCalculations(triggeringElement = null) {
            let totalResourcesFromBuildings = 0;
            let totalBuildingRate = 0;

            const buildingLevels = [
                document.getElementById('level1'),
                document.getElementById('level2'),
                document.getElementById('level3'),
                document.getElementById('level4'),
                document.getElementById('levelWeekly')
            ];
            const resourceBuildings = [
                document.getElementById('resource1'),
                document.getElementById('resource2'),
                document.getElementById('resource3'),
                document.getElementById('resource4'),
                document.getElementById('resourceWeekly')
            ];

            // --- Auto-population Logic ---
            // Only trigger auto-population if a 'resource' input was the triggering element
            if (triggeringElement && triggeringElement.id.startsWith('resource')) {
                const triggeredLevelId = 'level' + triggeringElement.id.replace('resource', '');
                const triggeredLevelElement = document.getElementById(triggeredLevelId);

                // Ensure triggeredLevelElement exists before trying to read its value
                if (triggeredLevelElement) {
                    const triggeredLevel = parseInt(triggeredLevelElement.value) || 0;
                    const triggeredResourceValue = getCleanNumber(triggeringElement.id);

                    // Iterate through all resource buildings for auto-population
                    for (let i = 0; i < resourceBuildings.length; i++) {
                        const currentResourceElement = resourceBuildings[i];
                        const currentLevelElement = buildingLevels[i]; // Get the corresponding level element
                        const currentLevel = parseInt(currentLevelElement.value) || 0;

                        // Don't auto-populate the element that just triggered the update
                        if (currentResourceElement.id === triggeringElement.id) {
                            continue;
                        }

                        const currentResourceValue = getCleanNumber(currentResourceElement.id);

                        // Auto-populate if levels match AND (target field is empty OR target field has the same value as source)
                        // The "same value as source" check allows subsequent auto-fills to overwrite
                        // previous auto-fills, but not manually changed values.
                        if (currentLevel > 0 && currentLevel === triggeredLevel &&
                            (currentResourceElement.value === '' || currentResourceValue === triggeredResourceValue)) {
                            
                            currentResourceElement.value = triggeredResourceValue.toString(); // Set the raw value
                            formatInput(currentResourceElement); // Immediately format the auto-populated field
                        }
                    }
                }
            }
            // --- End Auto-population Logic ---

            // --- Standard Calculations ---
            for (let i = 0; i < 5; i++) {
                let level = parseInt(buildingLevels[i].value) || 0; // Get level value for rate calculation
                if (level <= 30) { // Only levels up to 30 contribute to rate
                    totalBuildingRate += level;
                }
                let resource = getCleanNumber(resourceBuildings[i].id);
                totalResourcesFromBuildings += resource;
            }

            const resourceHeld = getCleanNumber('resourceHeldText');
            const resourceNeeded = getCleanNumber('resourceNeededText');

            const resourcePerHour = totalBuildingRate * 720;
            document.getElementById('resourceHrDisplay').textContent = resourcePerHour.toLocaleString('en-US');

            const totalCurrentResource = resourceHeld + totalResourcesFromBuildings;
            document.getElementById('totalResourceDisplay').textContent = totalCurrentResource.toLocaleString('en-US');

            const timeDisplay = document.getElementById('timeDisplay');
            const completionTimeDisplay = document.getElementById('completionTimeDisplay');

            // Get selected time zone for formatting
            const selectedTimeZoneId = document.getElementById('timezoneSelect').value;
            const resourceNeededInput = document.getElementById('resourceNeededText');


            // Only calculate and display time if resourceNeeded is filled and non-zero
            if (resourceNeeded > 0 && selectedTimeZoneId) {
                // Get current language for time display format strings
                const currentLangCode = document.getElementById('languageSelect').value;
                const currentTranslations = translations[currentLangCode] || translations['en'];

                let completionDateTime;
                let hoursValue;
                let timeFormatKey; // Key for translation string ('timeRemainingFormat' or 'timeAgoFormat')

                // Determine if we have enough resources or need more
                const neededRemaining = resourceNeeded - totalCurrentResource;

                if (neededRemaining <= 0) { // Have enough or more than enough
                    // If we have enough or more, the completion time is effectively "now" or "already done".
                    // The 'hoursValue' here indicates how much "over" the target we are (or 0).
                    hoursValue = (totalCurrentResource - resourceNeeded) / Math.max(1, resourcePerHour); // Divide by 1 if rate is 0 to avoid Infinity
                    completionDateTime = new Date(); // Completion is now for display purposes

                    if (resourcePerHour > 0 && hoursValue > 0.01) { // If overshot significantly and producing
                         timeFormatKey = 'timeAgoFormat'; // Use 'X hrs ago' if overshot and rate > 0
                         completionDateTime = new Date(Date.now() - hoursValue * 60 * 60 * 1000); // Calculate a past time
                    } else { // Exactly enough or slightly over, or zero rate
                        timeFormatKey = 'timeRemainingFormat'; // Display as "0.00 hrs"
                        hoursValue = 0; // Force to 0 for display consistency
                    }
                } else if (resourcePerHour > 0) { // Need more resources AND there's a production rate
                    hoursValue = neededRemaining / resourcePerHour;
                    completionDateTime = new Date(Date.now() + hoursValue * 60 * 60 * 1000);
                    timeFormatKey = 'timeRemainingFormat';
                } else { // Need more resources but no production rate
                    timeDisplay.textContent = "N/A";
                    completionTimeDisplay.textContent = "N/A";
                    // Call formatInput on blur as it also handles empty/invalid states
                    if (document.getElementById('resourceHeldText').value !== '') formatInput(document.getElementById('resourceHeldText'));
                    if (resourceNeededInput.value !== '') formatInput(resourceNeededInput);
                    if (triggeringElement && triggeringElement.id.startsWith('level') && triggeringElement.value !== '') {
                        formatInput(triggeringElement);
                    }
                    return; // Exit if cannot calculate
                }

                // Update Time to Complete display
                if (Math.abs(hoursValue) < 0.01 && resourceNeeded > 0) { // If hours are practically zero and there's a target
                     timeDisplay.textContent = currentTranslations['timeRemainingFormat'].replace('{hours}', '0.00'); // Always show 0.00
                } else {
                     const formattedHours = hoursValue.toFixed(2);
                     timeDisplay.textContent = currentTranslations[timeFormatKey].replace('{hours}', formattedHours);
                }

                // Update Completion Time display
                try {
                    let formattedTime;
                    let completionTzAbbr;

                    if (selectedTimeZoneId === "America/Honolulu") {
                        // Manually calculate Hawaii time (UTC-10) and format
                        // Get current UTC time
                        const utcHours = completionDateTime.getUTCHours();
                        const utcMinutes = completionDateTime.getUTCMinutes();
                        
                        // Apply UTC-10 offset. Adjust for rollover (e.g., if UTC 01:00 becomes -09:00 previous day)
                        let hawaiiHours = utcHours - 10;
                        let hawaiiDate = new Date(completionDateTime); // Start with a copy

                        if (hawaiiHours < 0) {
                            hawaiiHours += 24; // Adjust hours for previous day
                            hawaiiDate.setUTCDate(hawaiiDate.getUTCDate() - 1); // Move to previous day
                        } else if (hawaiiHours >= 24) { // Should not happen with -10 offset, but for robustness
                            hawaiiHours -= 24;
                            hawaiiDate.setUTCDate(hawaiiDate.getUTCDate() + 1);
                        }

                        // Format minutes to be '00'-padded
                        const hawaiiMinutes = utcMinutes.toString().padStart(2, '0');

                        // Convert to 12-hour format
                        const ampm = hawaiiHours >= 12 ? 'PM' : 'AM';
                        hawaiiHours = hawaiiHours % 12;
                        hawaiiHours = hawaiiHours ? hawaiiHours : 12; // The hour '0' should be '12 AM'

                        formattedTime = `${hawaiiHours}:${hawaiiMinutes} ${ampm}`;
                        completionTzAbbr = "HST"; // Hardcode abbreviation for Hawaii

                    } else {
                        // Use Intl.DateTimeFormat for other time zones
                        const timeFormatter = new Intl.DateTimeFormat('en-US', {
                            hour: 'numeric',
                            minute: 'numeric',
                            hour12: true,
                            timeZone: selectedTimeZoneId // Use the selected IANA ID here
                        });
                        formattedTime = timeFormatter.format(completionDateTime);

                        const actualCompletionOffsetHours = getNumericalOffsetInHours(selectedTimeZoneId, completionDateTime);
                        completionTzAbbr = getShortTimeZoneAbbreviation(selectedTimeZoneId, completionDateTime, actualCompletionOffsetHours);
                    }

                    // Construct the full completion time display string: Time AM/PM Abbreviation
                    completionTimeDisplay.textContent = `${formattedTime} ${completionTzAbbr}`;

                } catch (e) {
                    console.error(`Error formatting completion time for '${selectedTimeZoneId}': ${e.message}. Displaying UTC.`, e);
                    // Fallback to UTC display if any other error occurs
                    const utcFormatter = new Intl.DateTimeFormat('en-US', {
                        hour: 'numeric',
                        minute: 'numeric',
                        hour12: true,
                        timeZone: 'Etc/UTC', // Explicitly use UTC
                        timeZoneName: 'short'
                    });
                    completionTimeDisplay.textContent = `UTC: ${utcFormatter.format(completionDateTime)}`;
                }

            } else { // resourceNeeded is 0 or not filled, or no timezone selected
                timeDisplay.textContent = "N/A";
                completionTimeDisplay.textContent = "N/A";
            }
            // --- End Standard Calculations ---

            // Re-format the main resourceHeldText and resourceNeededText after calculations,
            // as they are not part of the auto-population loop for buildings.
            if (document.getElementById('resourceHeldText').value !== '') formatInput(document.getElementById('resourceHeldText'));
            if (resourceNeededInput.value !== '') formatInput(resourceNeededInput); // Use resourceNeededInput here for clarity
            // Re-format level fields if the triggering element was a level input
            if (triggeringElement && triggeringElement.id.startsWith('level') && triggeringElement.value !== '') {
                formatInput(triggeringElement);
            }
        }

        // ######################### Theme Logic #########################

        // Function to apply the theme (light, dark, or system)
        function applyTheme(theme) {
            const body = document.body;
            // Remove existing theme classes/attributes first
            body.removeAttribute('data-theme');

            if (theme === 'dark') {
                body.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            } else if (theme === 'light') {
                localStorage.setItem('theme', 'light');
            } else { // 'system'
                localStorage.removeItem('theme'); // Remove preference to default to system
                updateThemeFromSystemPreference(); // Immediately apply system preference
            }
        }

        // Function to get the theme preference (from localStorage or system)
        function getStoredTheme() {
            return localStorage.getItem('theme'); // 'light', 'dark', or null
        }

        // Function to update the theme based on system preference
        function updateThemeFromSystemPreference() {
            const body = document.body;
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                body.setAttribute('data-theme', 'dark');
            } else {
                body.removeAttribute('data-theme'); // Ensure light mode is default
            }
        }

        // Event listener for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            // Only react to system changes if no manual preference is set
            if (!getStoredTheme()) {
                updateThemeFromSystemPreference();
            }
        });

        // ######################### Initial Load #########################
        window.onload = () => {
            // 1. Populate language selector and apply translations.
            populateLanguageSelector();
            applyTranslations(); // This needs to run before the theme toggle text is set

            // 2. Populate timezone dropdowns.
            populateTimezones();

            // 3. Apply stored theme or system preference
            const storedTheme = getStoredTheme();
            if (storedTheme) {
                applyTheme(storedTheme);
            } else {
                updateThemeFromSystemPreference();
            }

            // 4. Set up theme toggle button
            const themeToggleButton = document.getElementById('theme-toggle');
            themeToggleButton.addEventListener('click', () => {
                const currentTheme = getStoredTheme(); // Get the currently applied manual preference
                if (currentTheme === 'dark') {
                    applyTheme('light');
                } else if (currentTheme === 'light') {
                    applyTheme('system'); // Next click goes to system default
                } else { // Currently 'system' or no preference saved (so system default is active)
                    applyTheme('dark');
                }
            });

            // 5. Set up instructions modal
            const instructionsButton = document.getElementById('instructions-button');
            const instructionsModal = document.getElementById('instructionsModal');
            const modalCloseButton = document.querySelector('.modal-close-button');

            instructionsButton.addEventListener('click', () => {
                instructionsModal.style.display = 'flex'; // Show the modal
            });

            modalCloseButton.addEventListener('click', () => {
                instructionsModal.style.display = 'none'; // Hide the modal
            });

            // Close modal if user clicks outside of it
            window.addEventListener('click', (event) => {
                if (event.target === instructionsModal) {
                    instructionsModal.style.display = 'none';
                }
            });

            // 6. Run initial calculations
            updateCalculations();
        };

        // Version 4.2.4 - Last Updated: June 13, 2025, 10:53 PM EDT
    </script>

</body>
</html>
